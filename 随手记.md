# MV*

* 解耦、职责分离

* MVP （model，view）依赖注入到 presenter

* 数据到图像的映射程序

* 一切即数据（0，1）

* 数据驱动

* 策略模式

* 观察者模式

* 组合模式

* AOP

* 接口实现
  * 工厂模式
  * 组合模式
  * 装饰模式
  * 命令模式

* gitlab 生命周期钩子

* 版本管理

* 字典、辞典、成语词典

* 《寻李白》绣口一吐，便是半个盛唐。咏雪：黑狗身上白，白狗身上肿

* 范式化

* MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(表示器)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))

* GoF并不将MVC引述为一种设计模式,而是把它看做是构建一个用户界面的类的集合.按照他们的观点,它实际上是三种经典设计模式的变异组合:观察者模式,策略模式和组件模式.依赖于框架中的MVC如何实现,它也可能会使用工厂和模板模式.GoF Book提到这些模式在使用MVC工作时是非常有用的附加功能。

如我们所讨论的,模型代表应用程序的数据,而视图则是用户在屏幕上看到的被展现出来的东西.如此,MVC它的一些核心的通讯就要依赖于观察者模式(令人惊奇的是,一些相关的内容在许多关于MVC模式的书籍并没有被涵盖到).当模型被改变时,它会通知观察者(视图)一些东西已经被更新了——这也许是MVC中最重要的关系。观察者的这一特性也是实现将多个视图连结到同一个模型的基础。

对于那些对MVC解耦特性想了解更多的开发者（这再一次依赖于特定的实现），这一模式的目标之一就是帮助去实现一个主体（数据对象）和它的观察者之间的一对多关系的定义。当一个主体发生改变的时候，它的观察者也会被更新。视图和控制器有一种稍微不同的关系.控制器协助视图对不同的用户输入做出响应,这也是一个策略模式的例子。

* 用于页面展示的数据和直接请求获取的数据有时不同需要处理。 直接获取到的源数据 => 业务逻辑处理 =>  用于页面展示的数据

* 页面展示异常
  * 渲染模板异常
  * 或 数据处理异常
  * 或 后台返回结果异常

* 表格

  ```HTML
    <html>
      <head></head>
      <body>
        <div id="app"></div>
      </body>
    </html>
    <script>
        const $APP = document.getElementById('app');
    </script>
  ```

  ```JavaScript
    // render template html
    const staffData = ajaxFun(params);

    $APP.innerHTML =
    `
    <input/>
    <botton id="search">搜索</botton>
    <div id="all"></div>
    <div id="one"></div>
    `

    const $ALL = document.getElementById('all');
    const $ONE = document.getElementById('one');
    const $SEARCH = document.getElementById('search');
    const $MODIFY = document.getElementById('modify');

    // render table
    const renderTable = params => {
        const table = document.createElement('table');
        table.innerHTML =
        `
        <table>
        <thead>
            <tr>
                <th>staff</th>
                <th>Scale</th>
                <th>Salary</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        </table>
        `
        const tbody = document.getElementsByTagName('tbody');
        const childrenTemple = params.map(item =>
        `
        <tr>
            <td>${item.name}</td>
            <td>${item.scale}</td>
            <td>${item.salary}</td>
        </tr>`).join();
        tbody.innerHTML = childrenTemple;
        return table;
    };

    // render search
    const filterStuff = params => staffData.filter(item => item.name == params);
    const handleModify = params => {
        console.log('修改'， params);
    }
    const renderSearch = params => {
        const table = document.createElement('table');
        table.innerHTML =
        `
        <table>
        <thead>
            <tr>
                <th>staff</th>
                <th>Scale</th>
                <th>Salary</th>
                <th>modify</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        </table>
        `
        const childrenTemple = params.map(item =>
        `
        <tr>
            <td><input value=${item.name} /></td>
            <td><input value=${item.scale} /></td>
            <td><input value=${item.salary} /></td>
            <td><botton class='modify' onclick=${handleModify(item))}>修改</botton></td>
        </tr>`).join();
    }
    const handleSearch = params => {
        $ONE.innerHTML = renderSearch(params);
    }

    $ALL.innerHTML = renderTable(staffData);

    $SEARCH.addEventListener('click', handleSearch, false);
  ```