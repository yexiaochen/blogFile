# 随手记

## 函数作用域, 闭包, this, 模块

* 变量在特定时间用于保存特定值, 变量的值及其数据类型可以在脚本的生命周期内改变.

* 将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值. 当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.

* 函数的参数, 函数内部的局部变量.

* 标识符解析是沿着作用域链一级一级地搜索标识符的过程. 搜索过程始终从作用域链的前端开始, 然后逐级地向后回溯, 直至找到标识符为止.

* 内部环境可以通过作用域链访问所有的外部环境, 但外部环境不能访问环境中的任何变量和函数. 这些环境之间的联系是线性、有次序的. 每个环境都可以向上搜索作用域链, 以查询变量和函数名. 但任何环境都不能通过向下搜索作用域而进入另一个执行环境. 局部变量只在函数执行的过程中存在.

* 基本类型值在内存中占据固定大小的空间, 被保存在栈内存中. 复杂类型保存在堆内存中.

* 箭头函数, 只有在函数体的表达式多于 1 个, 或者函数体包含非表达式语句的时候才需要用 `{...}` 包围. 如果只有一个表达式, 并且省略了包围的 `{...}` 的话, 则意味着表达式前面有一个隐含的 return.

## 设计模式

* 设计模式的定义是: 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案. 《设计模式》副标题为 “可复用面向对象软件的基础”. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出一些可重复使用的面向对象设计技巧. 所以有一种说法是设计模式仅仅是就面向对象的语言而言的.

* 所有设计模式的实现都遵循一条原则, 即“找出程序中变化的地方, 并将变化封装起来”. 一个程序的设计总是可以分为可变的部分和不变的部分. 找出可变的部分将其封装起来, 那么剩下的就是不变和稳定的部分. 将不变的隔离开来, 变化的封装起来.

* 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达. 对象以方法的形式包含了过程, 而闭包则是在过程中以环境的形式包含了数据. 通常用面向对象思想能实现的功能, 用闭包也能实现.

* 策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.

* 一个基于策略模式的程序至少由两部分组成. 第一部分时一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分时环境类 Context, Context 接受客服的请求, 随后把请求委托给某一个策略类. 要做到这一点, Context 中要维持对某个策略对象的应用. 策略模式的目的就是将算法的使用与算法的实现分离开来.

* 解耦、职责分离

* MVP （model，view）依赖注入到 presenter

* 数据到图像的映射程序

* 一切即数据（0，1）

* 数据驱动

* 策略模式

* 观察者模式

* 组合模式

* AOP

* 接口实现
  * 工厂模式
  * 组合模式
  * 装饰模式
  * 命令模式

* gitlab 生命周期钩子

* 版本管理

* 字典、辞典、成语词典

* 《寻李白》绣口一吐，便是半个盛唐。咏雪：黑狗身上白，白狗身上肿

* 范式化

* 如我们所讨论的,模型代表应用程序的数据,而视图则是用户在屏幕上看到的被展现出来的东西.如此,MVC它的一些核心的通讯就要依赖于观察者模式(令人惊奇的是,一些相关的内容在许多关于MVC模式的书籍并没有被涵盖到).当模型被改变时,它会通知观察者(视图)一些东西已经被更新了——这也许是MVC中最重要的关系。观察者的这一特性也是实现将多个视图连结到同一个模型的基础。

对于那些对MVC解耦特性想了解更多的开发者（这再一次依赖于特定的实现），这一模式的目标之一就是帮助去实现一个主体（数据对象）和它的观察者之间的一对多关系的定义。当一个主体发生改变的时候，它的观察者也会被更新。视图和控制器有一种稍微不同的关系.控制器协助视图对不同的用户输入做出响应,这也是一个策略模式的例子。

* 用于页面展示的数据和直接请求获取的数据有时不同需要处理。 直接获取到的源数据 => 业务逻辑处理 =>  用于页面展示的数据

* 页面展示异常
  * 渲染模板异常
  * 或 数据处理异常
  * 或 后台返回结果异常

## 异步

* 程序的一部分现在运行，而另一部分则在将来运行——现在和将来之间有间隙，在这段间隙中，程序没有活跃执行。

* 程序中将来执行的部分并已定在现在运行的部分执行之后就立即执行。换句话说，现在无法完成的任务将会一步完成。

* 回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。回调是 JavaScript 语言中最基础的异步模式。回调函数包裹或者说封装了程序的延续（continuation）。

* **大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致bug。我们需要一种同步、更顺序、更阻塞的方式来表达异步。**

* **回调表达异步和管理并发两个主要缺陷：缺乏顺序性和可信任性**。

* Promise 是一种封装和组合未来值的易于复用的机制。

* 显示创建并返回了一个事件订阅对象 evt，调用代码得到这个对象，并在其上注册了事件处理事件。回调本身就表达了一种控制反转。对回调模式的反转实际上是对反转的反转，或者称为反控制反转——把控制还给调用代码，evt 对象就是分离的关注点之间一个中立的第三方协商机制。

* 回调未调用 没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议。竞态。

```JavaScript
    Promise.race([
        foo(),
        timeoutPromise(time)
    ]).then()
```

* 可信任的Promise 如果向Promise。resolve(..) 传递一个非Promise、非thenable的立即值，就会的得到一个用这个值填充的promise。如果向Promise.resolve(..)传递一个非Promise的thenablezhi，前者就会试图展开这个值，而且展开过程会持续到提取一个具体的非类Promise的最终值。Promise。resolve(..)可以接受任何thenable，将其解封为它的非thenable值。如果传入的已经是真正的Promise，就会得到它本身。

* **对于用 Promise.resolve(..)为所有函数的返回值（不管是不是thenable）都封装一层。另一个好处是，这样很容易把函数调用规范为定义良好的异步任务。**

* **Promise 这种模式通过可信任的语义把回调作为参数传递，是的这种行为更可靠合理。通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统中，这种系统的设计目的就是为了异步编码更清晰**。

* **每次对Promise调用 then(..) ，它都会创建并返回一个新的Promise，可以将其链接起来；不管then(..)调用的完成回调（第一个参数）返回的值是什么，它都会自动设置为被链接Promise（前一点的）的完成。**

* 如果没有给then(..)传递一个适当有效的函数作为完成处理函数参数，还是会有作为替代的一个默认处理函数。默认的完成处理函数只是把接收到的任何传入值传递给下一个步骤（Promise）而已。

* 如果向reject(..)传入一个Promise/thenable值，它会把这个值原封不动地设置为拒绝理由。后续的拒绝处理函数接收到的是你实际传给reject(..)的那个Promise/thenable，而不是其底层的立即值。

* Promise(..)构造器的第一个回调函数的相当称谓是resolve(..). then(..)的是fulfilled(){},rejected(){}。

* Promise 错误处理易于出错，且容易造成错误被吞掉。如果通过无效的方式使用PromiseAPI，并且出现一个错误阻碍了正常的Promise构造，结果会得到一个立即抛出的异常，而不是一个给拒绝的Promise，如Promise(null)、Promise.all()、Promise.race(42).

* Promise.all([...]) 列表中的每个值都会通过Promise.resolve(...)过滤，以确保要等待的是一个真正的Promise，所以立即值会被规范化为这个值构建的Promise。如果数组是空的，主Promise就会立即完成。

* 在经典的编程术语中门（gate）是这样一种机制要等待两个或更多并行/并发的任务都完成才能继续。完成顺序不重要。

* 如果传入一个空数组，Promise.race([])永远不会决议。

* `new Promise`

```JavaScript
    new Promise(function(resolve, reject) {
        // resolve(...) 用于决议/完成着Promise
        // reject(...) 用于拒绝
    })
```

* 如果传入的真正的Promise， Promise.resolve(..)什么都不会做，只会直接把这个值返回。如果调用Promise.resolve(...)的恰好是真正的Promise，是不会有额外的开销的。

* 完全不能得到（对任何“已处理”的拒绝错误）错误通知也是一个缺陷，它限制了某些用例的功能。

* 一旦创建了一个Promise并为其注册了完成和/或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没办法从外部停止它的进程。

* **把基于回调的异步任务链与Promise链中需要移动的部分数量进行比较，很显然Promise进行的动作更多一些，更多的工作，更多的保护**。

* **Promise 使所有一切都成为异步的了，即有一些立即（同步）完成的步骤仍然会延迟到任务的下一步。这意味着一个Promise任务序列可能比完全通过回调连接的任务序列运行得稍微慢一点。**

* **Promise解决了我们因只用回调的代码而备受困扰的控制反转问题，它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其它工具间的可信任的中介机制。Promise链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步JavaScript代码。**

* **Promise不是对回调的代替。Promise在回调代码和将要执行这个任务的异步代码之间提供了一种可靠的中间机制来管理回调。**

* 有序性、可预测性和可靠性。

* Promise.resolve() 和 Promise.reject() 是手动创建一个已经resolve或者reject的promise快捷方法。它们有时很有用。

* **Promise被明确拒绝时，会发生拒绝；但是如果是在构造函数回调中引发的错误，则会隐式拒绝。在Promise构造函数回调内部执行所有与Promise相关的任务很有用，因为错误会自动捕获并进而拒绝。**

* Network initialor blackbox; Source eventListener call strack blackbox; globalvabial; breakpoint conditiona; Sources override style change local files;

* 模块有两个特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

* 假定：一个函数一旦开始执行，就会运行到结束，期间不会有其它代码能够打断它并插入其间。

* 生成器函数一类特殊函数，可以一次或多次启动和停止，并不一定给得要完成。构成以生成器作为异步流程控制的代码模式的基础构件之一。仍然是一个函数。

* yield会导致生成器再执行过程中发出一个值。

* 消息是双向传递的——yield.. 作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值。 yield.. 和 next(..) 组合起来，在生成器的执行过程中构成了一个双向床底系统。只有暂停的yield才能接受这样一个通过next(..)传递的值，而生成器的起始处调用第一个next()时，还没有暂停的yield来接受这样一个值。

* 通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。

*