# 随手记

* # 博客资料

## 函数作用域, 闭包, this, 模块

* 变量在特定时间用于保存特定值, 变量的值及其数据类型可以在脚本的生命周期内改变.

* 将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值. 当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.

* 函数的参数, 函数内部的局部变量.

* 标识符解析是沿着作用域链一级一级地搜索标识符的过程. 搜索过程始终从作用域链的前端开始, 然后逐级地向后回溯, 直至找到标识符为止.

* 内部环境可以通过作用域链访问所有的外部环境, 但外部环境不能访问环境中的任何变量和函数. 这些环境之间的联系是线性、有次序的. 每个环境都可以向上搜索作用域链, 以查询变量和函数名. 但任何环境都不能通过向下搜索作用域而进入另一个执行环境. 局部变量只在函数执行的过程中存在.

* 基本类型值在内存中占据固定大小的空间, 被保存在栈内存中. 复杂类型保存在堆内存中.

* 箭头函数, 只有在函数体的表达式多于 1 个, 或者函数体包含非表达式语句的时候才需要用 `{...}` 包围. 如果只有一个表达式, 并且省略了包围的 `{...}` 的话, 则意味着表达式前面有一个隐含的 return.

## 设计模式

* 设计模式的定义是: 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案. 《设计模式》副标题为 “可复用面向对象软件的基础”. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出一些可重复使用的面向对象设计技巧. 所以有一种说法是设计模式仅仅是就面向对象的语言而言的.

* 所有设计模式的实现都遵循一条原则, 即“找出程序中变化的地方, 并将变化封装起来”. 一个程序的设计总是可以分为可变的部分和不变的部分. 找出可变的部分将其封装起来, 那么剩下的就是不变和稳定的部分. 将不变的隔离开来, 变化的封装起来.

* 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达. 对象以方法的形式包含了过程, 而闭包则是在过程中以环境的形式包含了数据. 通常用面向对象思想能实现的功能, 用闭包也能实现.

* 策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.

* 一个基于策略模式的程序至少由两部分组成. 第一部分时一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分时环境类 Context, Context 接受客服的请求, 随后把请求委托给某一个策略类. 要做到这一点, Context 中要维持对某个策略对象的应用. 策略模式的目的就是将算法的使用与算法的实现分离开来.

* 解耦、职责分离

* MVP （model，view）依赖注入到 presenter

* 数据到图像的映射程序

* 一切即数据（0，1）

* 数据驱动

* 策略模式

* 观察者模式

* 组合模式

* AOP

* 接口实现
  * 工厂模式
  * 组合模式
  * 装饰模式
  * 命令模式

* gitlab 生命周期钩子

* 版本管理

* 字典、辞典、成语词典

* 《寻李白》绣口一吐，便是半个盛唐。咏雪：黑狗身上白，白狗身上肿

* 范式化

* MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(表示器)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))

* GoF并不将MVC引述为一种设计模式,而是把它看做是构建一个用户界面的类的集合.按照他们的观点,它实际上是三种经典设计模式的变异组合:观察者模式,策略模式和组件模式.依赖于框架中的MVC如何实现,它也可能会使用工厂和模板模式.GoF Book提到这些模式在使用MVC工作时是非常有用的附加功能。

如我们所讨论的,模型代表应用程序的数据,而视图则是用户在屏幕上看到的被展现出来的东西.如此,MVC它的一些核心的通讯就要依赖于观察者模式(令人惊奇的是,一些相关的内容在许多关于MVC模式的书籍并没有被涵盖到).当模型被改变时,它会通知观察者(视图)一些东西已经被更新了——这也许是MVC中最重要的关系。观察者的这一特性也是实现将多个视图连结到同一个模型的基础。

对于那些对MVC解耦特性想了解更多的开发者（这再一次依赖于特定的实现），这一模式的目标之一就是帮助去实现一个主体（数据对象）和它的观察者之间的一对多关系的定义。当一个主体发生改变的时候，它的观察者也会被更新。视图和控制器有一种稍微不同的关系.控制器协助视图对不同的用户输入做出响应,这也是一个策略模式的例子。

* 用于页面展示的数据和直接请求获取的数据有时不同需要处理。 直接获取到的源数据 => 业务逻辑处理 =>  用于页面展示的数据

* 页面展示异常
  * 渲染模板异常
  * 或 数据处理异常
  * 或 后台返回结果异常

* 表格

  ```HTML
    <html>
      <head></head>
      <body>
        <div id="app"></div>
      </body>
    </html>
    <script>
        const $APP = document.getElementById('app');
    </script>
  ```

  ```JavaScript
    // render template html
    const staffData = ajaxFun(params);

    $APP.innerHTML =
    `
    <input/>
    <botton id="search">搜索</botton>
    <div id="all"></div>
    <div id="one"></div>
    `

    const $ALL = document.getElementById('all');
    const $ONE = document.getElementById('one');
    const $SEARCH = document.getElementById('search');
    const $MODIFY = document.getElementById('modify');

    // render table
    const renderTable = params => {
        const table = document.createElement('table');
        table.innerHTML =
        `
        <table>
        <thead>
            <tr>
                <th>staff</th>
                <th>Scale</th>
                <th>Salary</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        </table>
        `
        const tbody = document.getElementsByTagName('tbody');
        const childrenTemple = params.map(item =>
        `
        <tr>
            <td>${item.name}</td>
            <td>${item.scale}</td>
            <td>${item.salary}</td>
        </tr>`).join();
        tbody.innerHTML = childrenTemple;
        return table;
    };

    // render search
    const filterStuff = params => staffData.filter(item => item.name == params);
    const handleModify = params => {
        console.log('修改'， params);
    }
    const renderSearch = params => {
        const table = document.createElement('table');
        table.innerHTML =
        `
        <table>
        <thead>
            <tr>
                <th>staff</th>
                <th>Scale</th>
                <th>Salary</th>
                <th>modify</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
        </table>
        `
        const childrenTemple = params.map(item =>
        `
        <tr>
            <td><input value=${item.name} /></td>
            <td><input value=${item.scale} /></td>
            <td><input value=${item.salary} /></td>
            <td><botton class='modify' onclick=${handleModify(item))}>修改</botton></td>
        </tr>`).join();
    }
    const handleSearch = params => {
        $ONE.innerHTML = renderSearch(params);
    }

    $ALL.innerHTML = renderTable(staffData);

    $SEARCH.addEventListener('click', handleSearch, false);
  ```