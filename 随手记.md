# 随手记

## 函数作用域, 闭包, this, 模块

* 变量在特定时间用于保存特定值, 变量的值及其数据类型可以在脚本的生命周期内改变.

* 将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值. 当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.

* 函数的参数, 函数内部的局部变量.

* 标识符解析是沿着作用域链一级一级地搜索标识符的过程. 搜索过程始终从作用域链的前端开始, 然后逐级地向后回溯, 直至找到标识符为止.

* 内部环境可以通过作用域链访问所有的外部环境, 但外部环境不能访问环境中的任何变量和函数. 这些环境之间的联系是线性、有次序的. 每个环境都可以向上搜索作用域链, 以查询变量和函数名. 但任何环境都不能通过向下搜索作用域而进入另一个执行环境. 局部变量只在函数执行的过程中存在.

* 基本类型值在内存中占据固定大小的空间, 被保存在栈内存中. 复杂类型保存在堆内存中.

* 箭头函数, 只有在函数体的表达式多于 1 个, 或者函数体包含非表达式语句的时候才需要用 `{...}` 包围. 如果只有一个表达式, 并且省略了包围的 `{...}` 的话, 则意味着表达式前面有一个隐含的 return.

## 设计模式

* 设计模式的定义是: 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案. 《设计模式》副标题为 “可复用面向对象软件的基础”. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出一些可重复使用的面向对象设计技巧. 所以有一种说法是设计模式仅仅是就面向对象的语言而言的.

* 所有设计模式的实现都遵循一条原则, 即“找出程序中变化的地方, 并将变化封装起来”. 一个程序的设计总是可以分为可变的部分和不变的部分. 找出可变的部分将其封装起来, 那么剩下的就是不变和稳定的部分. 将不变的隔离开来, 变化的封装起来.

* 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达. 对象以方法的形式包含了过程, 而闭包则是在过程中以环境的形式包含了数据. 通常用面向对象思想能实现的功能, 用闭包也能实现.

* 策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.

* 一个基于策略模式的程序至少由两部分组成. 第一部分时一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分时环境类 Context, Context 接受客服的请求, 随后把请求委托给某一个策略类. 要做到这一点, Context 中要维持对某个策略对象的应用. 策略模式的目的就是将算法的使用与算法的实现分离开来.

* 解耦、职责分离

* MVP （model，view）依赖注入到 presenter

* 数据到图像的映射程序

* 一切即数据（0，1）

* 数据驱动

* 策略模式

* 观察者模式

* 组合模式

* AOP

* 接口实现
  * 工厂模式
  * 组合模式
  * 装饰模式
  * 命令模式

* gitlab 生命周期钩子

* 版本管理

* 字典、辞典、成语词典

* 《寻李白》绣口一吐，便是半个盛唐。咏雪：黑狗身上白，白狗身上肿

* 范式化

* 如我们所讨论的,模型代表应用程序的数据,而视图则是用户在屏幕上看到的被展现出来的东西.如此,MVC它的一些核心的通讯就要依赖于观察者模式(令人惊奇的是,一些相关的内容在许多关于MVC模式的书籍并没有被涵盖到).当模型被改变时,它会通知观察者(视图)一些东西已经被更新了——这也许是MVC中最重要的关系。观察者的这一特性也是实现将多个视图连结到同一个模型的基础。

对于那些对MVC解耦特性想了解更多的开发者（这再一次依赖于特定的实现），这一模式的目标之一就是帮助去实现一个主体（数据对象）和它的观察者之间的一对多关系的定义。当一个主体发生改变的时候，它的观察者也会被更新。视图和控制器有一种稍微不同的关系.控制器协助视图对不同的用户输入做出响应,这也是一个策略模式的例子。

* 用于页面展示的数据和直接请求获取的数据有时不同需要处理。 直接获取到的源数据 => 业务逻辑处理 =>  用于页面展示的数据

* 页面展示异常
  * 渲染模板异常
  * 或 数据处理异常
  * 或 后台返回结果异常

## 异步

* 程序的一部分现在运行，而另一部分则在将来运行——现在和将来之间有间隙，在这段间隙中，程序没有活跃执行。

* 程序中将来执行的部分并已定在现在运行的部分执行之后就立即执行。换句话说，现在无法完成的任务将会一步完成。

* 回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。回调是 JavaScript 语言中最基础的异步模式。回调函数包裹或者说封装了程序的延续（continuation）。

* **大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致bug。我们需要一种同步、更顺序、更阻塞的方式来表达异步。**

* **回调表达异步和管理并发两个主要缺陷：缺乏顺序性和可信任性**。

* Promise 是一种封装和组合未来值的易于复用的机制。

* 显示创建并返回了一个事件订阅对象 evt，调用代码得到这个对象，并在其上注册了事件处理事件。回调本身就表达了一种控制反转。对回调模式的反转实际上是对反转的反转，或者称为反控制反转——把控制还给调用代码，evt 对象就是分离的关注点之间一个中立的第三方协商机制。

* 回调未调用 没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议。竞态。

```JavaScript
    Promise.race([
        foo(),
        timeoutPromise(time)
    ]).then()
```

* 可信任的Promise 如果向Promise。resolve(..) 传递一个非Promise、非thenable的立即值，就会的得到一个用这个值填充的promise。如果向Promise.resolve(..)传递一个非Promise的thenablezhi，前者就会试图展开这个值，而且展开过程会持续到提取一个具体的非类Promise的最终值。Promise。resolve(..)可以接受任何thenable，将其解封为它的非thenable值。如果传入的已经是真正的Promise，就会得到它本身。

* **对于用 Promise.resolve(..)为所有函数的返回值（不管是不是thenable）都封装一层。另一个好处是，这样很容易把函数调用规范为定义良好的异步任务。**

* **Promise 这种模式通过可信任的语义把回调作为参数传递，是的这种行为更可靠合理。通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统中，这种系统的设计目的就是为了异步编码更清晰**。

* **每次对Promise调用 then(..) ，它都会创建并返回一个新的Promise，可以将其链接起来；不管then(..)调用的完成回调（第一个参数）返回的值是什么，它都会自动设置为被链接Promise（前一点的）的完成。**

* 如果没有给then(..)传递一个适当有效的函数作为完成处理函数参数，还是会有作为替代的一个默认处理函数。默认的完成处理函数只是把接收到的任何传入值传递给下一个步骤（Promise）而已。

* 如果向reject(..)传入一个Promise/thenable值，它会把这个值原封不动地设置为拒绝理由。后续的拒绝处理函数接收到的是你实际传给reject(..)的那个Promise/thenable，而不是其底层的立即值。

* Promise(..)构造器的第一个回调函数的相当称谓是resolve(..). then(..)的是fulfilled(){},rejected(){}。

* Promise 错误处理易于出错，且容易造成错误被吞掉。如果通过无效的方式使用PromiseAPI，并且出现一个错误阻碍了正常的Promise构造，结果会得到一个立即抛出的异常，而不是一个给拒绝的Promise，如Promise(null)、Promise.all()、Promise.race(42).

* Promise.all([...]) 列表中的每个值都会通过Promise.resolve(...)过滤，以确保要等待的是一个真正的Promise，所以立即值会被规范化为这个值构建的Promise。如果数组是空的，主Promise就会立即完成。

* 在经典的编程术语中门（gate）是这样一种机制要等待两个或更多并行/并发的任务都完成才能继续。完成顺序不重要。

* 如果传入一个空数组，Promise.race([])永远不会决议。

* `new Promise`

```JavaScript
    new Promise(function(resolve, reject) {
        // resolve(...) 用于决议/完成着Promise
        // reject(...) 用于拒绝
    })
```

* 如果传入的真正的Promise， Promise.resolve(..)什么都不会做，只会直接把这个值返回。如果调用Promise.resolve(...)的恰好是真正的Promise，是不会有额外的开销的。

* 完全不能得到（对任何“已处理”的拒绝错误）错误通知也是一个缺陷，它限制了某些用例的功能。

* 一旦创建了一个Promise并为其注册了完成和/或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没办法从外部停止它的进程。

* **把基于回调的异步任务链与Promise链中需要移动的部分数量进行比较，很显然Promise进行的动作更多一些，更多的工作，更多的保护**。

* **Promise 使所有一切都成为异步的了，即有一些立即（同步）完成的步骤仍然会延迟到任务的下一步。这意味着一个Promise任务序列可能比完全通过回调连接的任务序列运行得稍微慢一点。**

* **Promise解决了我们因只用回调的代码而备受困扰的控制反转问题，它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其它工具间的可信任的中介机制。Promise链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步JavaScript代码。**

* **Promise不是对回调的代替。Promise在回调代码和将要执行这个任务的异步代码之间提供了一种可靠的中间机制来管理回调。**

* 有序性、可预测性和可靠性。

* Promise.resolve() 和 Promise.reject() 是手动创建一个已经resolve或者reject的promise快捷方法。它们有时很有用。

* **Promise被明确拒绝时，会发生拒绝；但是如果是在构造函数回调中引发的错误，则会隐式拒绝。在Promise构造函数回调内部执行所有与Promise相关的任务很有用，因为错误会自动捕获并进而拒绝。**

* Network initialor blackbox; Source eventListener call strack blackbox; globalvabial; breakpoint conditiona; Sources override style change local files;

* 模块有两个特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

* 假定：一个函数一旦开始执行，就会运行到结束，期间不会有其它代码能够打断它并插入其间。

* 生成器函数一类特殊函数，可以一次或多次启动和停止，并不一定给得要完成。构成以生成器作为异步流程控制的代码模式的基础构件之一。仍然是一个函数。

* yield会导致生成器再执行过程中发出一个值。

* 消息是双向传递的——yield.. 作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值。 yield.. 和 next(..) 组合起来，在生成器的执行过程中构成了一个双向床底系统。只有暂停的yield才能接受这样一个通过next(..)传递的值，而生成器的起始处调用第一个next()时，还没有暂停的yield来接受这样一个值。

* 通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。

* yield 关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。可以被认为是一个基于生成器的版本的return关键字。一旦遇到yield表达式，生成器的代码将被暂停运行，知道生成器的next()方法被调用。

* yeild关键字实际返回一个 IteratorResult 对象。

* yield* `yield*`表达式迭代操作数，并产生它返回的每个值，`yield*`表示式本身的值是当迭代器关闭时的返回的值。

* 调用Generator函数，会返回一个内部指针（即遍历器）g，执行它并不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针.

* 可以理解Generator函数是一个状态机，封装了多个内部状态。执行Generator函数返回一个遍历器对象，返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。

* 函数体内部使用yield表达式定义不同的内部状态。

* JavaScript 表示集合的数据结构 Array、Object、Map 、Set。统一的接口机制，来处理所有不同的数据结构。遍历器，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）

* 创建一个指针对象，指向当前数据结构的起始位置。遍历器对象本质上，就是一个指针对象。

```JavaScript
    function makeIterator(array) {
        var nextIndex = 0;
        return {
            next: function() {
                return nextIndex < array.length ?
                {value: array[nextIndex++]} :
                {done: true};
            }
        };
    }
```

* 当使用for...of 循环遍历某种数据结构时，该循环会去寻找Iterator接口。一种数据结构只要部署了Iterator接口，我们就称这种数据结构是‘可遍历的’。ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator，即一个数据结构只要具有Symbol.iterator属性，就可以认为是‘可遍历的’。 Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。

* Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义的，类型为Symbol的特殊值。

* 原生具备 Iterator 接口的数据结构有，Array, Map, Set, String, TypeArray, arguments对象，NodeList对象。

* 遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就是等于部署一种线性转换，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用。

```JavaScript
    class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }

  [Symbol.iterator]() { return this; }

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    }
    return {done: true, value: undefined};
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}

for (var value of range(0, 3)) {
  console.log(value); // 0, 1, 2
}
```

* 调用Iterator接口：
  * 解构赋值。

  ```JavaScript
    let set = new Set().add('a').add('b').add('c');
    let [x,y] = set;
    let [first, ...rest] = set;
  ```

  * 扩展运算符 (...)

  ```JavaScript
    var str = 'hello';
    [...str] //  ['h','e','l','l','o']
    let arr = ['b', 'c'];
    ['a', ...arr, 'd']
  ```

  * yield*

    ```JavaScript
    let generator = function* () {
    yield 1;
    yield* [2,3,4];
    yield 5;
    };

    var iterator = generator();

    iterator.next() // { value: 1, done: false }
    iterator.next() // { value: 2, done: false }
    iterator.next() // { value: 3, done: false }
    iterator.next() // { value: 4, done: false }
    iterator.next() // { value: 5, done: false }
    iterator.next() // { value: undefined, done: true }
    ```

    * 其它
      * for...of
      * Array.from()
      * Map(), Set(), WeakMap, WeakSet(eg. `new Map([['a',1],['b',2]])`)
      * Promise.all()
      * Promise.race()

* Iterator & Generator

  ```JavaScript
    let myIterable = {
    [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
        yield 3;
    }
    }
    [...myIterable] // [1, 2, 3]
    // 或者采用下面的简洁写法
    let obj = {
    * [Symbol.iterator]() {
        yield 'hello';
        yield 'world';
    }
    };

    for (let x of obj) {
    console.log(x);
    }
  ```

  * 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法

  * Genarator函数可以暂停执行和恢复执行，函数体内外的数据交换和错误处理机制。

  * Generator 函数是分段执行的，yield表达式是暂停执行的标记，next可以恢复执行。

  * yield 表达式后面的表达式，只有当调用next方法、内部指针指向该语法时才会执行，因此等于JavaScript提供了手动的‘惰性求值’的语法功能。

  * 任意一个对象的 Symbol.iterator 方法， 等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。

  * gen 是一个Generator函数，调用它会生成一个遍历对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。

  * 一个函数 一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。

  * 构建以生成器作为异步流控制的代码模式的基础构件之一， 提供内建消息输入输出能力，通过yield和next(...)实现。

  * 消息是双向传递的——yield... 作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停yield表达式发送值。yield和next组合起来，在生成器的执行过程中构成了了一个双向消息传递系统。

  * 如果你的生成器中没有return的话——在生成器中和在不同函数中一样，return当然不是必须的——总有一个假定的/隐式的return。（也就是return undefined）

  * 每次构建一个迭代器，实际上就是隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。

  * 迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值。迭代器永不结束是没问题的。

  * fo..of循环在每次迭代中自动调用next(),还不会想 next() 传入任何值，并且会在接收到done：true之后自动停止。

  * iterable(可迭代), 即指一个包含可以在其值上迭代的迭代器的对象。 从ES6开始，从一个iterable 中提取迭代器的方法是：iterable 必须支持一个函数，其名称是专门的 ES6 符号值 Symbol.iterator。 调用这个函数时，它会返回一个迭代器。通常每次调用会返回一个全新的迭代器，虽然这一点不是必须的。

  * while..true 如果在生成器中有 yield 的话，使用这样的循环就完全没有问题。因为生成器会在每次迭代中暂停，通过 yield 返回到主程序或事件循环队列中。因为生成器会在每个 yield 处暂停，函数 *something() 的状态（作用域）会被保持，即意味着不需要闭包在调用之间保持变量状态。

  * for..of 循环的‘异常结束’（即提前终止），通常有 break、return或者未捕获异常引起，会向生成器发送一个信号使其终止。如果在生成器内有 try..finally 语句 ，它将总是运行，即使生成器已经外部结束。

  * 消费生产者

  * 生成器 yield 暂停的特性意味这我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误。错误抛入生成器中，生成器可以向外抛出异常，甚至可以捕获 throw(..) 抛入生成器的同一个错误，基本上也就是个生成器一个处理机会；如果没有处理的话，迭代器代码就必须处理。

  * ES6 中最完美的世界就是生成器（看似同步的异步代码）和 Promise（可信任可组合）的结合。

  * 获得 Promise 和生成器最大效用的最自然的方法就是 yield  出来一个 Promise，然后通过这个 Promise 来控制生成器的迭代器。

  * 组合 Promise 和看似同步的流程控制代码，有效实际解决了我们列出的回调方案的主要问题。

  * Promise 所有的并发问题在生成器 + Promise 方法中都可使用。所以无论在什么地方的需求超过了顺序的 this-then-that 异步流程控制，Promise 很可能都是最好的选择。

  * 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码，将异步细节尽可能隐藏起来。有意将这样的细节从生成器代码中抽象出来，以避免它把高层次的任务表达变得杂乱。创建代码除了要实现功能和保持性能之外，你还应该尽可能使代码易于理解和维护。

  * yield* 委托，把迭代器实例控制委托给/转移给另一个迭代器。

  * yield 委托的主要目的使代码组织，以达到于普通函数调用的对称。保持生成器分离有助于程序的可读性、可维护性和可调式性。

  * 和 yield 委托透明地双向传递消息的方式一样，错误和异常也是双向传递的。

  * 两个同时运行的进程可以合作方式地交替运作，而很多时候可以产生强大的异步表示。

  * 假定从生成器 yield 出一个 Promise， 并且让这个 Promise 通过一个像 run 这样的辅助函数恢复这个生成器，这是通过生成器管理异步的最好方式。

  * 形实转换程序， JavaScript 中的 thunk 使指一个用于调用另一个函数的函数，没有任何参数。换句话说，用一个函数定义封装函数调用，包括需要的任何参数，来定义这个调用的执行，那么这个封装函数就是一个形实转换程序。之后在执行这个 thunk 时，最终就是调用了原始的函数。

  * 生成器使通过暂停自己的作用域/状态实现它的‘魔法’的。

  * **生成器使 ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 yield 实现的。不过，只有控制生成器的迭代器具有恢复生成器的能力（通过 next..））**

  * **yield/next(..)这一对不只是一种控制机制，实际上也是双向消息传递机制。yield..表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined）**

  * **在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步/顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后面，把异步移动到控制生成器的迭代器的代码部分。**

  * 换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然追踪代码，解决了基于回调的异步的两个关键缺陷之一。

  * 异步不只是对应用性能直观重要，而且正在慢慢称为代码易写性和可维护性方面的关键因素。回调编码的缺陷： 控制反转信任缺失和线性理解能力的确实。

  * Promise 是对‘未来值’的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合它们。另外，通过一种可信任、可组合的 Promise 机制，分发回调它们，也有效地解决了IoC信任问题。

  * 生成器为JavaScript 函数引入了一种新的执行模式，其中生成器可以暂停在 yield 点上，并在之后被异步继续。暂停与继续的能里使得生成器中同步的、看似连续的代码可以在后台异步执行。通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。

  * 利用通用模式来组织和复用代码显著提高了代码的可读性和可礼节性。记住：对于代码来说，和其他开发者交流与提供计算机指令同等重要。

  * 迭代器是一个结构化的模式，用于从源以一次一个的方式提取数据。这个模式在编程中已经使用相当长的一段时间了。

  * ES6 实现的是为引入一个隐式的标准化接口。JavaScript 很多内建的数据结构现在都提供了实现这个标准的迭代器。为了达到最大化的互操作性，也可以自己构建符合这个标准的迭代器。

  * 迭代器是一种有序的、连续的、基于垃取的用于消耗数据的组织方式。

  * return(..) 被定义为向迭代器发送一个信号，表明消费者代码已经完毕，不会再从其中提取任何值。这个信号可以用于通知生产者（响应next(..)调用的迭代器）执行可能需要清理工作，比如释放/关闭网络、数据库或者文件句柄资源

  * 通过生成器迭代器，throw(..)实际上向生成器的停滞执行上下文中插入了一个抛出的异常，这个异常可以用 try..catch 捕获。未捕获的 throw(..) 异常最终会异常终止生成器迭代器。

  * 所有的函数都运行知道完毕，换句话说，一旦一个函数开始运行，在它结束之前不会被任何事打断。 而ES6引入了一个全新的某种程度上说是奇异的函数形式，称为生成器。生成器可以在执行当中暂停自身，可以立即恢复执行也可以过一段事件之后恢复执行。所以显然它并不向不同函数那样保证运行到完毕。在执行当中的每次暂停/恢复循环都提供了一个双向信息传递的机会，生成器可以返回一个值，恢复它的控制代码可以发回一个值。

  * **yield 不只是一个暂停点。它是一个表达式，在暂停生成器的时候发送一个值。yield..表达式不只发送一个值——没有值的 yield 等价于 yield undefined——而且还会接收（也就是被替换成）最终的恢复值。**

  * **每一个 yield 都会导致这个生成器暂停等待一个恢复值，然后把这个恢复值用在各种表达式上下文中。**

  * yield 严格来说，yield.. 和像 a = 3 这样的复制表达式有同样的‘表达式优先级’ ————类似于运算符优先级的概念。这意味着yield.. 基本上可以出现在任何 a = 3 合法出现的位置。

  * 当一个暂停的 yield 表达式恢复的时候，它会被完成/替代为它的恢复值，采取的方式和‘赋值’给这个值是一样的。

  * 因为 yield 关键字的优先级很低，几乎 yield.. 之后的任何表达式都会首先计算，然后再通过 yield 发送。只有 spread 运算符...和逗号运算符，拥有更低的优先级。

  * yield* .. 需要一个 iterable；然后它会调用这个 iterable 的迭代器，把自己的生成器控制委托给这个迭代器，直至其耗尽。

  * 使用 yield..，表达式的完成值来自于用 it.next(..)恢复生成器的值，而对于 yield*.. 表达式来说，完成值来自于被委托的迭代器的返回值（如果有的话）

  * yield..表达式用恢复生成器所用的值完成。这意味着传给 next(..) 的参数完成了当前 yield.. 表达式暂停等待完成的。

  * **第一个 next() 调用初始的暂停状态启动生成器，运行知道第一个 yield。在调用第一个 next() 的时候，并没有 yield.. 表达式等待完成。如果向第一个 next()调用传入一个值，这个值会马上被丢弃，因为并没有 yield 等待接收这个值。**

  * **把生成器看作是值的产生者，其中每次迭代就是产生一个值来消费。把生成器看成一个受控的、可传递的代码执行。**

  * 在生成器的内部执行上下文被暂停时，程序的其余部分仍是未被阻塞的，包括控制生成器恢复的异步动作能力。

  * 生成器上附着的迭代器支持可选的 rturn() 和throw()方法，这两种方法都有立即终止一个暂停的生成器的效果。

  * 正如 return(X) 基本上就是在生成器中的当前暂停点插入了一个 return x，调用 throw() 基本上就相当于在暂停点插入一个 throw x

  * 和 return 不同，迭代器的 throw(..) 方法从来不会被自动调用。

  * 任何提供了 then(..) 函数的对象（或函数）都被认为是 thenable。Promise 机制中所有可以接收真正 promise 状态的地方，也都可以处理 thenable。

  * 控制反转（Inversion of Control）, 是面向对象的一种设计原则，可以用来降低计算机代码之间的耦合。其中最常见的方式是依赖注入（Dependency Injection）。可有一种方式是依赖查找（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个控制系统内所有对象的外界实体，将其多依赖的对象的引用传递给它。可以说，依赖被注入到对象中。
  ‘哪些方面的控制被反转了？’，依赖对象的获得被反转了，因为大多数引用程序说是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。

  * 依赖反转原则（Dependency inversion principle），是一种特定的解耦（传统的依赖关系建立在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖与高层次模块的需求抽象。
  该原则规定：
    1. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
    2. 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。

  * 在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和底层组件划分到不同的库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。

  * 依赖注入（Dependency injection），将所有东西现在外面准备好，然后带入内部的程式中，如此一来就能够见识程式码的时候，一目了然地知道这个程式依赖着哪些类别。

  * 依赖注入容器（Dependency injection container, DIC）.

  * **“反转”的是上下层的依赖，由之前的上层依赖下层的实现，反转成下层依赖上层的接口。**

  * 在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。

## TypeScript

* 基本类型和基本类型构造函数。
* void 表示没有任何返回值。null、undefined 和void 区别，undefined和null是所有类型的子类型。而void类型的变量不能赋值给其它类型的变量。
* 声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。
* 变量如果在声明的时候，为指定其类型，那么它会被识别为任意值类型。
* 类型推论，如果定义的时候没有赋值，不管以后有没有赋值，都会被推断成 any 类型而完全不被类型检查。
* 联合类型表示可以为多种类型中的一种。`|` 分隔每个类型。当TypeScript不确定一个联合类型的变量到底哪个类型时，只能访问此联合类型的所有类型里共有的属性或方法。
* 接口，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状」进行描述。
  * 接口一般首字母大写。有的编程语言建议接口名称前加I前缀。
  * 不允许定义的变量比接口少/多了一些属性。
  * 赋值的时候，变量的形状必须和接口的形状保持一致。
  * 可选属性， prop？：type。仍不允许添加未定义的属性。
  * 允许有任意属性，[propName: string|number|...]: type。一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集。
  * 只读属性，readonly prop: type。只读的约束在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候。
* 数组类型表示法, `any` 表达数组中允许出现任意类型。
  * `type []`，数组的项中不允许出现非指定的类型数据。
  * `Array<type>`
  * 接口描述数组

  ```JavaScript
  interface NumberArray {
    [index: number]: number;
  }
  ```

* 类数组，常见类数组都有子集的接口，IArguments， NodeList， HTMLLollection 等。
* 函数类型
  * 函数声明，输入多于的（或者少于要求的）参数，是不被允许的。

  ```JavaScript
  function name(param: type, params: type): type{},输入与输出。
  ```

* 函数表达式, 在TypeScript的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。

  ```JavaScript
  let mySun: (x: number, y: number) => number = function(x: number, y: number):number{
    ruturn x+y;
  }
  ```

  * 接口定义函数形状。

  ```JavaScript
  interface func{
    (source: string, subing: string): boolean;
  }
  ```

  * 可选参数，与接口中的可选属性类型，用`?`表示可选参数。可选参数必须在必须参数后面。

  * TypeScript 会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须在必须参数后面」的限制了。

  ```JavaScript
  function buildNam(firstName: string = 'tom', lastName: string){}
  ```

  * 剩余参数，可用数组类型定义它

  ```JavaScript
  function push(array: any[], ...items: any[]){}
  ```

  * 重载， 允许一个函数接收不同数量或类型的参数时，作出不同的处理。

  ```JavaScript
  function reverse(x:number): number
  function reverse(x:string): string
  function reverse(x:number|string): number|string{}
  ```

  * 类型断言
    * `<type> value` | `value as type`, TypeScript 不确定一个联合类型的变量类型时，只能访问此联合类型的所有类型里共有的属性或方法。类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。

    ```JavaScript
    function getLength(somethin: string | number): number {
      if ((<string>something).length){
        return (<string>something).length;
      } else {
        return something.toString().length;
      }
    }
    ```

  * 声明文件，当使用第三方库时，需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。`declare var`,通常会把声明语句放到一个单独的文件（jQuery.d.ts）中，声明文件必须以 `.d.ts` 为后缀。这只是全局变量这种模式声明文件。

  ```JavaScript
  declare var jQuery: (selector: string) => any;
  ```

  * 通过模块导入的方式使用第三方库，引入声明文件方式。`@type`统一管理第三方库的声明文件.

  ```JavaScript
  npm install @type/jquery --save-dev
  ```

  * 当第三方库没有提供声明文件时，需要自己书写声明文件
    * 全局变量：`<script>`标签，注入全局变量。
    * npm包：`import * from '*'`，ES6模块规范
    * UMD库，模块插件，

  * 类型别名，类型别名用来给一个类型重新命名，常用语联合类型。

  * 字符串字面量类型，用来约束只能是某几个字符串中的一个。类型别名和字符串字面量类型都是使用 type 进行定义。
  
  * 元组，数组合并了相同类型的对象，而元组合并了不同类型的对象。
    * 当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。
    * 当添加越界元素时，它的类型会被限制为元组中每个类型的联合类型。

  * 枚举，用于取值被限定在一定范围内的场景。`enum`
    * 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值进行反向映射。未手动赋值的枚举项会接着上一个枚举项递增。
    * 如果紧接在计算所得项后面是未手动赋值的项，那么它就会因为无法获得初始值而报错。常数项和计算所得项。
    * 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。

  * 类
    * 类：定义了事物的抽象特点，包含属性和方法。
    * 封装：将对数据的操作细节隐藏起来，只暴露对外的接口。
    * 继承：子类继承父类，子类除了拥有父类所有的特性外，还有一些更具体的特性。
    * 多态：由继承而产生了相关不同的类，对同一个方法可以有不同响应。
    * 存取器：用以改变属性的读取和赋值行为。
    * 修饰符：限定了成员或类型的性质。
    * 抽象类：是提供其它类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现。
    * 接口：不同类之间共有的属性或方法，可以抽象成一个接口。接口可以被类实现。一个类只能继承自另一个类，但是可以实现多个接口。
    * 静态方法：`static`修饰的方法，不需要实例化，直接通过类调用。
    * 实例属性，静态属性。

  * 访问修饰符，public、privat、protected
    * public，修饰的属性和方法是共有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。
    * private，修饰的属性和方法是私有的，不能在声明它的类的外部（子类也不可以访问）访问。
    * protected，修饰的属性和方法是受保护的，和 private 类似，不过可以在子类中访问到。

  * 抽象类，abstract 用于定义抽象类和其中抽象方法
    * 抽象类是不允许被实例化的
    * 抽象类中的抽象方法必须被子类实现

    ```JavaScript
    abstract class Animal {
      public name;
      public constructor(name) {
        this.name = name;
      }
      public abstract sayHi();
    }
    class Cat extends Animal {
      public sayHi() {
        console.log('ddd')
      }
    }
    ```

    * 类的类型

    ```JavaScript
    class Anima {
      name: string,
      constructor(name: string) {
        this.name = name;
      }
      sayHi(): string {
        return '***'
      }
    }
    let a: Animal = new Animal("Jack");
    ```

  * 类与接口
    * 类实现接口。接口，不同类之间共有的特性，implements 关键字。一个类可以实现多个接口。

    ```JavaScript
    interface Alarm {
      alert()
    }
    interface Light {
      lightOn();
      lightOff();
    }
    class Car implements Alarm, Light {
      alert(){
        console.log('11')
      }
      lightOn(){
        console.log('22')
      }
      lightOff(){
        console.log('33')
      }
    }
    ```

    * 接口继承接口

    ```JavaScript
    interface Alarm{
      alert()
    }
    interface LightAlarm Alarm {
      lightOn();
      lightOff();
    }
    ```

    * 接口继承类

    ```JavaScript
    class Point {
      x: number;
      y: number;
    }
    interface Point3d extends Point{
      z: number
    }
    let point3d: Point3d = {x: 1, y:3, z: 3}
    ```

    * 混合类型

    ```JavaScript
    interface Counter {
      (start: number): string;
      interval: number;
      reset(): void;
    }
    function getCount: Counter {
      let couter = <Counter>function (start: nubmer) {};
      counter.interval = 123;
      counter.reset = function (){};
      return counter;
    }
    ```

  * 类型注解： TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。

  * 接口，只要两个类型内部的结构兼容那么这两个类型就是兼容的，这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。

  * any, Object, {}, 试图使用 Object， {} 表示一个值可以具有任意属性，然而在这种情况下，any 是真正想要使用的类型，因为它是最灵活的类型。最普通的类型但是允许在上面做任何事情，使用any时，将会失去大多数 TypeScript 提供的错误检查和编译器支持。 当决定使用 Objec 和 {}， 应该选择{}.

* 基本类型
  
  ```JavaScript
  let isDone: boolean = false;
  let decLiteral: number = 6;
  let name: string = "bob";
  let list: number[] = [1, 2, 3];
  let list: Array<number> = [1, 2, 3];
  let x: [string, number];
  enum Color {Red, Green, Blue}
  let notSure: any = 4;
  function warnUser(): void {
    console.log("This is my warning message");
  }
  let u: undefined = undefined;
  let n: null = null;
  function error(message: string): never {
    throw new Error(message);
  }
  declare function create(o: object | null): void;
  create({ prop: 0 });
  ```

* TypeScript 的核心原则之一是对值所具有的结构进行类型检查，它有时被称做「鸭式变型法」或「结构性子类型化」。接口作用就是为了这些类型命名和为你的代码或第三方代码定义契约。类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。
  * 可选属性，？，对可能存在的属性进行预定义；捕获引用了不存在的属性是的错误。
  * 只读属性，readonly，`ReadonlyArray<T>`
  * 额外的属性检查，对象字面量对被特殊对待而且会经过额外属性检查，当它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何「目标类型」不包含的属性时，会抛错。
    * 绕开检查，类型断言，字符串索引签名，
    ***类型推断***
  * 函数类型，调用签名，函数参数名不需要与接口里定义的名字相匹配。函数参数会逐个进行检查，要求对应位置上的参数类型是兼容的。
  * 类，接口描述了类的公共部分，而不是公共和私有部分。它不会检查类是否具有某些私有成员。
    * 静态部分和实例部分。构造函数签名。
  *接口继承类，继承类的成员但不包括其实现，当创建了一个接口继承了一个拥有私有的或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现。

* 类，传统 JavaScript 使用函数和基于原型的继承来创建可重用的组件。
  * 抽象类，作为其它派生类的基类使用，一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节。 abstract 用于定义抽象类和在抽象类内部定义抽象方法。抽象类的抽象方法不包含具体实现并且必须在派生类中实现。抽象方法必须包含abstract关键字并且可以包含访问修饰符。
  * 类定义会创建两个东西： 类的实例类型和一个构造函数。因为类可以创建类型，所以能够在允许使用接口的地方使用类。

* 函数，函数时 JavaScript 应用程序的基础。它帮助你实现抽象层，模拟类，信息隐藏和模块。定义行为的地方。
  * 函数类型包含两部分： 参数类型和返回值类型。
  * 赋值语句一边指定了类型但另一边没有类型的话，TypeScript 编译器会自动识别出类型。按上下文归类，时类型推论的一种。
  * TypeScript 里的每个函数参数都是必须的，编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。
  * 可选参数必须跟在参数后面。在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说可选参数与末尾的默认参数共享参数类型。与普通可选参数不一样，带默认值的参数不需要赶在必须参数的后面。必须明确传入 undefined 值来获得默认值。

* 泛型，类型变量，它是一种特殊的变量，只用与表示类型而不是值。跟踪函数里使用的类型的信息。
  * 没必要使用 <> 来明确地传入类型： 类型推论帮助我们保持代码精简和高可读性。
  * 类型推论，编译器会根据传入的参数自动地帮助我们确定类型。
  * 使用泛型创建泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。即，你必须把这些参数当作是任意或所有类型。
  * 泛型函数的类型只是有一个类型参数在最前面。带有调用签名的对象字面量来定义范型函数。
  * 除了范型接口，我们还可以创建范型类。注意， 无法创建范型枚举和范型命名空间。
  * 与接口一样，直接把范型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。范型类指的是实例部分的类型，所以类的静态属性不能使用这个范型类型。
  * 范型约束，定义一个接口来描述约束条件，使用这个接口和 extends 关键字来实现约束。

* 类型推断，即，类型是在哪里如何被推断的。
  * 最佳通用类型。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有的候选类型的类型。
  * 上下文归类。按上下文归类会发生在表达式的类型与所处的位置相关时。如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 any 类型，而且也不会报错。我们也可以明确地为函数参数类型赋值类覆写上下文类型。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。

* 类型兼容性，TypeScript 里的类型兼容性时基于结构子类型的。结构类型是一种只是用其成员来描述类型的方式。允许某些在编译阶段无法确认其安全性的操作。
  * x 要兼容 y，y 至少具有与 x 相同的属性。只有目标类型的成员会被一一检查是否兼容。
  * 在 Typescript 兼容性： 子类型和赋值。不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和 any 来回赋值，以及 enum 和对应数字值之间的来回赋值。

* 高级类型
  * 交叉类型，将多个类型合并为一个类型，把现有的多种类型叠加到一起成为一种类型，包含了所需的所有类型的特性。&。
  * 联合类型，表示一个值可以是几种类型之一。如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。
  * 用户自定义的类型守卫，类型首位就是一些表达式，它们会在运行时检查以确保在某个作用域的类型。谓词 parametername is Type。
  * typeof 类型守卫，typeof 类型首位只有两种形式能被识别： typeof v=== "typename"， typeof v !== "typename", typename 必须是 number， string， boolean 或symbol。但是 typeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。
  * instanceof 类型守卫，通过构造函数来细化类型的一种方式
  * null，undefi。默认情况下，类型检查其认为null 与 undefined 可以赋值给任何类型。null，undefined 区别对待， string|null， string、undefin ， string|undefin|null 是不同类型。
  * 类型别名，会为类型起一个别名。类型别名有时和接口很想，但是可以作用于元史之，联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型。使用类型别名在属性里引用自己，类型别名不能出现在声明右侧的任何地方。
  * 接口 VS 类型别名，类型别名不能被 extends 和 implements 。因为软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量使用接口代替类型别名。另外，若无法通过接口描述一个类型并且需要使用两盒类型或元组类型，这是通常会使用类型别名。
  * 可辨识联合，合并单例类型，两盒类型，类型是守卫和类型别名来创建一个叫做可辨识联合的高级模式，也称做标签联合或代数数据类型。1，单例类型属性-可辨识特征。2，一个类型别名包含了那些类型的联合。3，此属性上的类型守卫。

## 终端插件

* git colorize zsh-autosuggestions zsh-syntax-highlighting zsh-syntax-highlighting zsh-nvm
