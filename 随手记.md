# 随手记

## 函数作用域, 闭包, this, 模块

* 变量在特定时间用于保存特定值, 变量的值及其数据类型可以在脚本的生命周期内改变.

* 将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值. 当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.

* 函数的参数, 函数内部的局部变量.

* 标识符解析是沿着作用域链一级一级地搜索标识符的过程. 搜索过程始终从作用域链的前端开始, 然后逐级地向后回溯, 直至找到标识符为止.

* 内部环境可以通过作用域链访问所有的外部环境, 但外部环境不能访问环境中的任何变量和函数. 这些环境之间的联系是线性、有次序的. 每个环境都可以向上搜索作用域链, 以查询变量和函数名. 但任何环境都不能通过向下搜索作用域而进入另一个执行环境. 局部变量只在函数执行的过程中存在.

* 基本类型值在内存中占据固定大小的空间, 被保存在栈内存中. 复杂类型保存在堆内存中.

* 箭头函数, 只有在函数体的表达式多于 1 个, 或者函数体包含非表达式语句的时候才需要用 `{...}` 包围. 如果只有一个表达式, 并且省略了包围的 `{...}` 的话, 则意味着表达式前面有一个隐含的 return.

## 设计模式

* 设计模式的定义是: 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案. 《设计模式》副标题为 “可复用面向对象软件的基础”. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出一些可重复使用的面向对象设计技巧. 所以有一种说法是设计模式仅仅是就面向对象的语言而言的.

* 所有设计模式的实现都遵循一条原则, 即“找出程序中变化的地方, 并将变化封装起来”. 一个程序的设计总是可以分为可变的部分和不变的部分. 找出可变的部分将其封装起来, 那么剩下的就是不变和稳定的部分. 将不变的隔离开来, 变化的封装起来.

* 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达. 对象以方法的形式包含了过程, 而闭包则是在过程中以环境的形式包含了数据. 通常用面向对象思想能实现的功能, 用闭包也能实现.

* 策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.

* 一个基于策略模式的程序至少由两部分组成. 第一部分时一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分时环境类 Context, Context 接受客服的请求, 随后把请求委托给某一个策略类. 要做到这一点, Context 中要维持对某个策略对象的应用. 策略模式的目的就是将算法的使用与算法的实现分离开来.

* 解耦、职责分离

* MVP （model，view）依赖注入到 presenter

* 数据到图像的映射程序

* 一切即数据（0，1）

* 数据驱动

* 策略模式

* 观察者模式

* 组合模式

* AOP

* 接口实现
  * 工厂模式
  * 组合模式
  * 装饰模式
  * 命令模式

* gitlab 生命周期钩子

* 版本管理

* 字典、辞典、成语词典

* 《寻李白》绣口一吐，便是半个盛唐。咏雪：黑狗身上白，白狗身上肿

* 范式化

* 如我们所讨论的,模型代表应用程序的数据,而视图则是用户在屏幕上看到的被展现出来的东西.如此,MVC它的一些核心的通讯就要依赖于观察者模式(令人惊奇的是,一些相关的内容在许多关于MVC模式的书籍并没有被涵盖到).当模型被改变时,它会通知观察者(视图)一些东西已经被更新了——这也许是MVC中最重要的关系。观察者的这一特性也是实现将多个视图连结到同一个模型的基础。

对于那些对MVC解耦特性想了解更多的开发者（这再一次依赖于特定的实现），这一模式的目标之一就是帮助去实现一个主体（数据对象）和它的观察者之间的一对多关系的定义。当一个主体发生改变的时候，它的观察者也会被更新。视图和控制器有一种稍微不同的关系.控制器协助视图对不同的用户输入做出响应,这也是一个策略模式的例子。

* 用于页面展示的数据和直接请求获取的数据有时不同需要处理。 直接获取到的源数据 => 业务逻辑处理 =>  用于页面展示的数据

* 页面展示异常
  * 渲染模板异常
  * 或 数据处理异常
  * 或 后台返回结果异常

## 异步

* 程序的一部分现在运行，而另一部分则在将来运行——现在和将来之间有间隙，在这段间隙中，程序没有活跃执行。

* 程序中将来执行的部分并已定在现在运行的部分执行之后就立即执行。换句话说，现在无法完成的任务将会一步完成。

* 回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。回调是 JavaScript 语言中最基础的异步模式。回调函数包裹或者说封装了程序的延续（continuation）。

* **大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致bug。我们需要一种同步、更顺序、更阻塞的方式来表达异步。**

* **回调表达异步和管理并发两个主要缺陷：缺乏顺序性和可信任性**。

* Promise 是一种封装和组合未来值的易于复用的机制。

* 显示创建并返回了一个事件订阅对象 evt，调用代码得到这个对象，并在其上注册了事件处理事件。回调本身就表达了一种控制反转。对回调模式的反转实际上是对反转的反转，或者称为反控制反转——把控制还给调用代码，evt 对象就是分离的关注点之间一个中立的第三方协商机制。

* 回调未调用 没有任何东西（甚至JavaScript错误）能阻止Promise向你通知它的决议。竞态。

```JavaScript
    Promise.race([
        foo(),
        timeoutPromise(time)
    ]).then()
```

* 可信任的Promise 如果向Promise。resolve(..) 传递一个非Promise、非thenable的立即值，就会的得到一个用这个值填充的promise。如果向Promise.resolve(..)传递一个非Promise的thenablezhi，前者就会试图展开这个值，而且展开过程会持续到提取一个具体的非类Promise的最终值。Promise。resolve(..)可以接受任何thenable，将其解封为它的非thenable值。如果传入的已经是真正的Promise，就会得到它本身。

* **对于用 Promise.resolve(..)为所有函数的返回值（不管是不是thenable）都封装一层。另一个好处是，这样很容易把函数调用规范为定义良好的异步任务。**

* **Promise 这种模式通过可信任的语义把回调作为参数传递，是的这种行为更可靠合理。通过把回调的控制反转反转回来，我们把控制权放在了一个可信任的系统中，这种系统的设计目的就是为了异步编码更清晰**。

* **每次对Promise调用 then(..) ，它都会创建并返回一个新的Promise，可以将其链接起来；不管then(..)调用的完成回调（第一个参数）返回的值是什么，它都会自动设置为被链接Promise（前一点的）的完成。**

* 如果没有给then(..)传递一个适当有效的函数作为完成处理函数参数，还是会有作为替代的一个默认处理函数。默认的完成处理函数只是把接收到的任何传入值传递给下一个步骤（Promise）而已。

* 如果向reject(..)传入一个Promise/thenable值，它会把这个值原封不动地设置为拒绝理由。后续的拒绝处理函数接收到的是你实际传给reject(..)的那个Promise/thenable，而不是其底层的立即值。

* Promise(..)构造器的第一个回调函数的相当称谓是resolve(..). then(..)的是fulfilled(){},rejected(){}。

* Promise 错误处理易于出错，且容易造成错误被吞掉。如果通过无效的方式使用PromiseAPI，并且出现一个错误阻碍了正常的Promise构造，结果会得到一个立即抛出的异常，而不是一个给拒绝的Promise，如Promise(null)、Promise.all()、Promise.race(42).

* Promise.all([...]) 列表中的每个值都会通过Promise.resolve(...)过滤，以确保要等待的是一个真正的Promise，所以立即值会被规范化为这个值构建的Promise。如果数组是空的，主Promise就会立即完成。

* 在经典的编程术语中门（gate）是这样一种机制要等待两个或更多并行/并发的任务都完成才能继续。完成顺序不重要。

* 如果传入一个空数组，Promise.race([])永远不会决议。

* `new Promise`

```JavaScript
    new Promise(function(resolve, reject) {
        // resolve(...) 用于决议/完成着Promise
        // reject(...) 用于拒绝
    })
```

* 如果传入的真正的Promise， Promise.resolve(..)什么都不会做，只会直接把这个值返回。如果调用Promise.resolve(...)的恰好是真正的Promise，是不会有额外的开销的。

* 完全不能得到（对任何“已处理”的拒绝错误）错误通知也是一个缺陷，它限制了某些用例的功能。

* 一旦创建了一个Promise并为其注册了完成和/或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没办法从外部停止它的进程。

* **把基于回调的异步任务链与Promise链中需要移动的部分数量进行比较，很显然Promise进行的动作更多一些，更多的工作，更多的保护**。

* **Promise 使所有一切都成为异步的了，即有一些立即（同步）完成的步骤仍然会延迟到任务的下一步。这意味着一个Promise任务序列可能比完全通过回调连接的任务序列运行得稍微慢一点。**

* **Promise解决了我们因只用回调的代码而备受困扰的控制反转问题，它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其它工具间的可信任的中介机制。Promise链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步JavaScript代码。**

* **Promise不是对回调的代替。Promise在回调代码和将要执行这个任务的异步代码之间提供了一种可靠的中间机制来管理回调。**

* 有序性、可预测性和可靠性。

* Promise.resolve() 和 Promise.reject() 是手动创建一个已经resolve或者reject的promise快捷方法。它们有时很有用。

* **Promise被明确拒绝时，会发生拒绝；但是如果是在构造函数回调中引发的错误，则会隐式拒绝。在Promise构造函数回调内部执行所有与Promise相关的任务很有用，因为错误会自动捕获并进而拒绝。**

* Network initialor blackbox; Source eventListener call strack blackbox; globalvabial; breakpoint conditiona; Sources override style change local files;

* 模块有两个特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

* 假定：一个函数一旦开始执行，就会运行到结束，期间不会有其它代码能够打断它并插入其间。

* 生成器函数一类特殊函数，可以一次或多次启动和停止，并不一定给得要完成。构成以生成器作为异步流程控制的代码模式的基础构件之一。仍然是一个函数。

* yield会导致生成器再执行过程中发出一个值。

* 消息是双向传递的——yield.. 作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值。 yield.. 和 next(..) 组合起来，在生成器的执行过程中构成了一个双向床底系统。只有暂停的yield才能接受这样一个通过next(..)传递的值，而生成器的起始处调用第一个next()时，还没有暂停的yield来接受这样一个值。

* 通过一个迭代器控制生成器的时候，似乎是在控制声明的生成器函数本身。每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。

* yield 关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。可以被认为是一个基于生成器的版本的return关键字。一旦遇到yield表达式，生成器的代码将被暂停运行，知道生成器的next()方法被调用。

* yeild关键字实际返回一个 IteratorResult 对象。

* yield* `yield*`表达式迭代操作数，并产生它返回的每个值，`yield*`表示式本身的值是当迭代器关闭时的返回的值。

* 调用Generator函数，会返回一个内部指针（即遍历器）g，执行它并不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针.

* 可以理解Generator函数是一个状态机，封装了多个内部状态。执行Generator函数返回一个遍历器对象，返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。

* 函数体内部使用yield表达式定义不同的内部状态。

* JavaScript 表示集合的数据结构 Array、Object、Map 、Set。统一的接口机制，来处理所有不同的数据结构。遍历器，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）

* 创建一个指针对象，指向当前数据结构的起始位置。遍历器对象本质上，就是一个指针对象。

```JavaScript
    function makeIterator(array) {
        var nextIndex = 0;
        return {
            next: function() {
                return nextIndex < array.length ?
                {value: array[nextIndex++]} :
                {done: true};
            }
        };
    }
```

* 当使用for...of 循环遍历某种数据结构时，该循环会去寻找Iterator接口。一种数据结构只要部署了Iterator接口，我们就称这种数据结构是‘可遍历的’。ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator，即一个数据结构只要具有Symbol.iterator属性，就可以认为是‘可遍历的’。 Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。

* Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义的，类型为Symbol的特殊值。

* 原生具备 Iterator 接口的数据结构有，Array, Map, Set, String, TypeArray, arguments对象，NodeList对象。

* 遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就是等于部署一种线性转换，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用。

```JavaScript
    class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }

  [Symbol.iterator]() { return this; }

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    }
    return {done: true, value: undefined};
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop);
}

for (var value of range(0, 3)) {
  console.log(value); // 0, 1, 2
}
```

* 调用Iterator接口：
  * 解构赋值。

  ```JavaScript
    let set = new Set().add('a').add('b').add('c');
    let [x,y] = set;
    let [first, ...rest] = set;
  ```

  * 扩展运算符 (...)

  ```JavaScript
    var str = 'hello';
    [...str] //  ['h','e','l','l','o']
    let arr = ['b', 'c'];
    ['a', ...arr, 'd']
  ```

  * yield*

    ```JavaScript
    let generator = function* () {
    yield 1;
    yield* [2,3,4];
    yield 5;
    };

    var iterator = generator();

    iterator.next() // { value: 1, done: false }
    iterator.next() // { value: 2, done: false }
    iterator.next() // { value: 3, done: false }
    iterator.next() // { value: 4, done: false }
    iterator.next() // { value: 5, done: false }
    iterator.next() // { value: undefined, done: true }
    ```

    * 其它
      * for...of
      * Array.from()
      * Map(), Set(), WeakMap, WeakSet(eg. `new Map([['a',1],['b',2]])`)
      * Promise.all()
      * Promise.race()

* Iterator & Generator

  ```JavaScript
    let myIterable = {
    [Symbol.iterator]: function* () {
        yield 1;
        yield 2;
        yield 3;
    }
    }
    [...myIterable] // [1, 2, 3]
    // 或者采用下面的简洁写法
    let obj = {
    * [Symbol.iterator]() {
        yield 'hello';
        yield 'world';
    }
    };

    for (let x of obj) {
    console.log(x);
    }
  ```

  * 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法

  * Genarator函数可以暂停执行和恢复执行，函数体内外的数据交换和错误处理机制。

  * Generator 函数是分段执行的，yield表达式是暂停执行的标记，next可以恢复执行。

  * yield 表达式后面的表达式，只有当调用next方法、内部指针指向该语法时才会执行，因此等于JavaScript提供了手动的‘惰性求值’的语法功能。

  * 任意一个对象的 Symbol.iterator 方法， 等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。

  * gen 是一个Generator函数，调用它会生成一个遍历对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。

  * 一个函数 一旦开始执行，就会运行到结束，期间不会有其他代码能够打断它并插入其间。

  * 构建以生成器作为异步流控制的代码模式的基础构件之一， 提供内建消息输入输出能力，通过yield和next(...)实现。

  * 消息是双向传递的——yield... 作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停yield表达式发送值。yield和next组合起来，在生成器的执行过程中构成了了一个双向消息传递系统。

  * 如果你的生成器中没有return的话——在生成器中和在不同函数中一样，return当然不是必须的——总有一个假定的/隐式的return。（也就是return undefined）

  * 每次构建一个迭代器，实际上就是隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。

  * 迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值。迭代器永不结束是没问题的。

  * fo..of循环在每次迭代中自动调用next(),还不会想 next() 传入任何值，并且会在接收到done：true之后自动停止。

  * iterable(可迭代), 即指一个包含可以在其值上迭代的迭代器的对象。 从ES6开始，从一个iterable 中提取迭代器的方法是：iterable 必须支持一个函数，其名称是专门的 ES6 符号值 Symbol.iterator。 调用这个函数时，它会返回一个迭代器。通常每次调用会返回一个全新的迭代器，虽然这一点不是必须的。

  * while..true 如果在生成器中有 yield 的话，使用这样的循环就完全没有问题。因为生成器会在每次迭代中暂停，通过 yield 返回到主程序或事件循环队列中。因为生成器会在每个 yield 处暂停，函数 *something() 的状态（作用域）会被保持，即意味着不需要闭包在调用之间保持变量状态。

  * for..of 循环的‘异常结束’（即提前终止），通常有 break、return或者未捕获异常引起，会向生成器发送一个信号使其终止。如果在生成器内有 try..finally 语句 ，它将总是运行，即使生成器已经外部结束。

  * 消费生产者

  * 生成器 yield 暂停的特性意味这我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误。错误抛入生成器中，生成器可以向外抛出异常，甚至可以捕获 throw(..) 抛入生成器的同一个错误，基本上也就是个生成器一个处理机会；如果没有处理的话，迭代器代码就必须处理。

  * ES6 中最完美的世界就是生成器（看似同步的异步代码）和 Promise（可信任可组合）的结合。

  * 获得 Promise 和生成器最大效用的最自然的方法就是 yield  出来一个 Promise，然后通过这个 Promise 来控制生成器的迭代器。

  * 组合 Promise 和看似同步的流程控制代码，有效实际解决了我们列出的回调方案的主要问题。

  * Promise 所有的并发问题在生成器 + Promise 方法中都可使用。所以无论在什么地方的需求超过了顺序的 this-then-that 异步流程控制，Promise 很可能都是最好的选择。

  * 使用生成器实现异步的方法的全部要点在于创建简单、顺序、看似同步的代码，将异步细节尽可能隐藏起来。有意将这样的细节从生成器代码中抽象出来，以避免它把高层次的任务表达变得杂乱。创建代码除了要实现功能和保持性能之外，你还应该尽可能使代码易于理解和维护。

  * yield* 委托，把迭代器实例控制委托给/转移给另一个迭代器。

  * yield 委托的主要目的使代码组织，以达到于普通函数调用的对称。保持生成器分离有助于程序的可读性、可维护性和可调式性。

  * 和 yield 委托透明地双向传递消息的方式一样，错误和异常也是双向传递的。

  * 两个同时运行的进程可以合作方式地交替运作，而很多时候可以产生强大的异步表示。

  * 假定从生成器 yield 出一个 Promise， 并且让这个 Promise 通过一个像 run 这样的辅助函数恢复这个生成器，这是通过生成器管理异步的最好方式。

  * 形实转换程序， JavaScript 中的 thunk 使指一个用于调用另一个函数的函数，没有任何参数。换句话说，用一个函数定义封装函数调用，包括需要的任何参数，来定义这个调用的执行，那么这个封装函数就是一个形实转换程序。之后在执行这个 thunk 时，最终就是调用了原始的函数。

  * 生成器使通过暂停自己的作用域/状态实现它的‘魔法’的。

  * 生成器使 ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 yield 实现的。不过，只有控制生成器的迭代器具有恢复生成器的能力（通过 next..））

  * yield/next(..)这一对不只是一种控制机制，实际上也是双向消息传递机制。yield..表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined）

  * 在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步/顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后面，把异步移动到控制生成器的迭代器的代码部分。

  * 换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然追踪代码，解决了基于回调的异步的两个关键缺陷之一。

  * 异步不只是对应用性能直观重要，而且正在慢慢称为代码易写性和可维护性方面的关键因素。回调编码的缺陷： 控制反转信任缺失和线性理解能力的确实。

  * Promise 是对‘未来值’的与时间无关的封装，使得不管这个值是否已经可用，你都可以推导和组合它们。另外，通过一种可信任、可组合的 Promise 机制，分发回调它们，也有效地解决了IoC信任问题。

  * 生成器为JavaScript 函数引入了一种新的执行模式，其中生成器可以暂停在 yield 点上，并在之后被异步继续。暂停与继续的能里使得生成器中同步的、看似连续的代码可以在后台异步执行。通过这种方式，我们解决了回调的非线性、非局部跳转引发的代码混乱问题，因而让我们的异步代码看似同步，更容易追踪。

  * 利用通用模式来组织和复用代码显著提高了代码的可读性和可礼节性。记住：对于代码来说，和其他开发者交流与提供计算机指令同等重要。

  * 迭代器是一个结构化的模式，用于从源以一次一个的方式提取数据。这个模式在编程中已经使用相当长的一段时间了。

  * ES6 实现的是为引入一个隐式的标准化接口。JavaScript 很多内建的数据结构现在都提供了实现这个标准的迭代器。为了达到最大化的互操作性，也可以自己构建符合这个标准的迭代器。

  * 迭代器是一种有序的、连续的、基于垃取的用于消耗数据的组织方式。

  * return(..) 被定义为向迭代器发送一个信号，表明消费者代码已经完毕，不会再从其中提取任何值。这个信号可以用于通知生产者（响应next(..)调用的迭代器）执行可能需要清理工作，比如释放/关闭网络、数据库或者文件句柄资源

  * 通过生成器迭代器，throw(..)实际上向生成器的停滞执行上下文中插入了一个抛出的异常，这个异常可以用 try..catch 捕获。未捕获的 throw(..) 异常最终会异常终止生成器迭代器。

  * 所有的函数都运行知道完毕，换句话说，一旦一个函数开始运行，在它结束之前不会被任何事打断。 而ES6引入了一个全新的某种程度上说是奇异的函数形式，称为生成器。生成器可以在执行当中暂停自身，可以立即恢复执行也可以过一段事件之后恢复执行。所以显然它并不向不同函数那样保证运行到完毕。在执行当中的每次暂停/恢复循环都提供了一个双向信息传递的机会，生成器可以返回一个值，恢复它的控制代码可以发回一个值。

  * yield 不只是一个暂停点。它是一个表达式，在暂停生成器的时候发送一个值。yield..表达式不只发送一个值——没有值的 yield 等价于 yield undefined——而且还会接收（也就是被替换成）最终的恢复值。

  * 每一个 yield 都会导致这个生成器暂停等待一个恢复值，然后把这个恢复值用在各种表达式上下文中。

  * yield 严格来说，yield.. 和像 a = 3 这样的复制表达式有同样的‘表达式优先级’ ————类似于运算符优先级的概念。这意味着yield.. 基本上可以出现在任何 a = 3 合法出现的位置。

  * 当一个暂停的 yield 表达式恢复的时候，它会被完成/替代为它的恢复值，采取的方式和‘赋值’给这个值是一样的。

  * 因为 yield 关键字的优先级很低，几乎 yield.. 之后的任何表达式都会首先计算，然后再通过 yield 发送。只有 spread 运算符...和逗号运算符，拥有更低的优先级。

  * yield* .. 需要一个 iterable；然后它会调用这个 iterable 的迭代器，把自己的生成器控制委托给这个迭代器，直至其耗尽。

  * 使用 yield..，表达式的完成值来自于用 it.next(..)恢复生成器的值，而对于 yield*.. 表达式来说，完成值来自于被委托的迭代器的返回值（如果有的话）

  * yield..表达式用恢复生成器所用的值完成。这意味着传给 next(..) 的参数完成了当前 yield.. 表达式暂停等待完成的。

  * 第一个 next() 调用初始的暂停状态启动生成器，运行知道第一个 yield。在调用第一个 next() 的时候，并没有 yield.. 表达式等待完成。如果向第一个 next()调用传入一个值，这个值会马上被丢弃，因为并没有 yield 等待接收这个值。

  * 把生成器看作是值的产生者，其中每次迭代就是产生一个值来消费。把生成器看成一个受控的、可传递的代码执行。

  * 在生成器的内部执行上下文被暂停时，程序的其余部分仍是未被阻塞的，包括控制生成器恢复的异步动作能力。

  * 生成器上附着的迭代器支持可选的 rturn() 和throw()方法，这两种方法都有立即终止一个暂停的生成器的效果。

  * 正如 return(X) 基本上就是在生成器中的当前暂停点插入了一个 return x，调用 throw() 基本上就相当于在暂停点插入一个 throw x

  * 和 return 不同，迭代器的 throw(..) 方法从来不会被自动调用。

  * 任何提供了 then(..) 函数的对象（或函数）都被认为是 thenable。Promise 机制中所有可以接收真正 promise 状态的地方，也都可以处理 thenable。