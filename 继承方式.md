1. JavaScript 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 引用指向的都是同一个值.它们相互之间没有引用/指向关系.

都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.
‘什么, 你说这套逻辑之前写过?!?! 速速把代码交上来!!!’.
最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格. 在 ***JavaScript*** 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 ***apply***, ***call***, ***new*** 等方法也拓宽了函数的使用场景. 除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用.

```JavaScript
    function Animal(name) {
        this.name = name
    }
    Animal.prototype.species = 'animal'
```

原型链继承
```JavaScript
    function Animal(name) {
        this.name = name
    }
    Animal.prototype.species = 'animal'

    function Leo() {}

    Leo.prototype = new Animal()
```
缺点: 覆写原型, contructor被更改. Animal里的属性被Leo的实例共享. 创建Leo实例时, 无法向Animal构造函数传参.

借用构造函数
```JavaScript
    function Animal(name) {
        this.name = name
    }
    function Leo(name) {
        Animal.call(this, name)
    }
```
缺点: 无法共享方法. 但可以传参了.

组合继承
```JavaScript
        function Animal(name) {
        this.name = name
    }
    Animal.prototype.species = 'animal'

    function Leo(name) {
        Animal.call(this, name)
    }

    Leo.prototype = new Animal()
    Leo.prototype.contructor = Leo
```
缺点: 两次调用超类型构造函数Animal.

原型式继承: 借助原型基于已有的对象 Object.create() 行为相同.

```JavaScript
    function object(o) {
        function F() {}
        F.prototype = o
        return new F()
    }
```
缺点: 包含引用类型值的属性始终被共享, 类似挂在原型上.

寄生式继承
```JavaScript
    function object(o) {
        function F() {}
        F.prototype = o
        return new F()
    }

    function object(o) {
        let clone = object(o)
        clone.sayHi = function() {}
        return clone
    }
```
缺点: 同上, 仅是增强.

寄生组合式继承
```JavaScript
        function Animal(name) {
        this.name = name
    }
    Animal.prototype.species = 'animal'

    function Leo(name) {
        Animal.call(this, name)
    }

    inheritPrototype(Leo, Animal)

    Leo.prototype.someFun = function() {}

    function inheritPrototype(subType, superType) {
        var prototype = object(superType.prototype)
        prototype.constructor = subType
        subType.prototype = prototype;
    }
```